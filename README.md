# recursion-lec

# Scope
> Scope в JavaScript определяет доступность переменных внутри функций, блоков кода и программы в целом. 
# Бывают 3 типа scope в JavaScript: 

## 1. Global scope – доступен в программе в целом. Переменные, объявленные в глобальной области видимости, могут быть использованы в любой функции или блоке кода. 

* Пример:
```js

var name = "John";

function showMessage() {
  console.log("Hello, " + name);
}

showMessage(); // выводит "Hello, John"
```

## 2. Function scope – доступен только в пределах функции, в которой объявлены. 

* Пример:

```js
function showMessage() {
  var message = "Hello, World!";
  console.log(message);
}

showMessage(); // выводит "Hello, World!"
console.log(message); // выдает ошибку, так как переменная message вне функции
```

## 3. Block scope – доступен только в пределах блока кода (объявлены с помощью let и const). 

* Пример:

```js
if (true) {
  let message = "Hello, World!";
  console.log(message);
}

console.log(message); // выдает ошибку, так как переменная message вне блока кода
```

> Block scope также может быть использован для циклов и функций. 

> Например, в цикле for: 

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i); // выдает ошибку, так как переменная i вне цикла for
```

> Или в функции:

```js
function showMessage() {
  if (true) {
    let message = "Hello, World!";
    console.log(message);
  }
  
  console.log(message); // выдает ошибку, так как переменная message вне блока кода if
}

showMessage();
```

# Что такое hoisting in js
> Hoisting в JavaScript - это механизм, который позволяет объявлять переменные и функции до того, как они будут фактически определены в коде. Это происходит благодаря тому, что интерпретатор JavaScript сначала проходит по всему коду и "поднимает" объявления переменных и функций (а не их значения) вверх до начала кода.

> Вот пример объявления переменной до ее определения:

```js
console.log(age); // undefined
var age = 25;
```

> Здесь переменная age объявляется после первой строки кода, но при запуске кода интерпретатор сначала "поднимет" объявление переменной, а затем выполнит вывод ее значения. Поэтому в консоли мы увидим undefined, что означает, что переменная age есть, но ее значение не определено.

> То же самое происходит и с функциями:

```js
sayHello(); // "Hello"

function sayHello() {
  console.log("Hello");
}

```
> Здесь функция sayHello() вызывается до ее объявления, но интерпретатор сначала "поднимет" ее объявление, а затем выполнит вызов функции.

> Однако, стоит обратить внимание на то, что hoisting работает только для объявления переменных и функций, но не для их значений. Например:

```js
console.log(name); // ReferenceError: name is not defined
let name = "Tom";
```

> Здесь переменная name объявляется с использованием let, и если мы попытаемся обратиться к ее значению до ее объявления, мы получим ошибку.

> Hoisting может привести к непредвиденным результатам и сложностям в отладке кода, поэтому рекомендуется всегда объявлять переменные и функции перед их использованием в коде.

# Recursion
> Рекурсия — это техника, при которой функция вызывает саму себя для решения задачи. Рекурсия широко используется в программировании, особенно в функциональном программировании и алгоритмах.

* Пример функции, которая считает факториал числа при помощи рекурсии:

```js
function factorial(num) {
  if (num === 0 || num === 1) {
    return 1;
  } else {
    return num * factorial(num-1);
  }
}

console.log(factorial(5)); // выводит 120
```

> Функция factorial проверяет, является ли аргумент num равным 0 или 1. Если да, то возвращает 1, потому что факториал 0 и 1 равен 1. Если нет, то функция вызывает сама себя, передавая аргумент num-1, для вычисления факториала предыдущего числа. Каждый вызов функции уменьшает аргумент на единицу, пока num станет равным 0 или 1.

* Вот еще один пример рекурсии - функция для поиска максимального числа в массиве:

```js
function findMax(arr, n) {
  if (n === 1) {
    return arr[0];
  }

  return Math.max(arr[n - 1], findMax(arr, n - 1));
}

console.log(findMax([20, 50, 10, 30, 40], 5)); // выводит 50
```

> Функция findMax принимает два аргумента: массив и числовое значение n, которое отслеживает текущую позицию в массиве. Если n равно 1, то возвращает первый элемент массива arr[0]. Иначе функция вызывает сама себя, передавая аргументы arr и n-1, и находит максимальное число в массиве путем сравнения последнего элемента arr[n-1] и максимального числа в массиве до этого момента.

> Рекурсия может быть очень полезной в решении некоторых задач, но ее следует использовать с осторожностью, так как неправильно написанная рекурсия может привести к вычислительному переполнению и ошибкам в выполнении программы.

# closure
> Замыкание (Closure) в JavaScript - это функция, которая имеет доступ к переменным из вышестоящего контекста - даже после того, как вышестоящая функция завершила свое выполнение. Замыкания позволяют сохранять значения переменных и использовать их внутри функции.

- Вот пример кода с использованием замыкания:

```js
function multiplyBy(x) {
  return function(y) {
    return x * y;
  }
}

let multiplyByTwo = multiplyBy(2);
console.log(multiplyByTwo(5)); // выводит 10
```

> Здесь функция multiplyBy возвращает другую функцию, которая умножает свой аргумент на x. Вызов ${multiplyBy(2)} создает новую функцию, которая умножает свой аргумент на число 2. Затем мы сохраняем эту новую функцию в переменную ${multiplyByTwo}. Когда мы вызываем ${multiplyByTwo(5)}, она умножает свой аргумент на значение x из вышестоящей функции, то есть на 2, и возвращает результат умножения, который составляет 10.

- Вот еще один пример использования замыкания для создания приватных переменных:

```js
function counter() {
  let count = 0;

  return {
    increment() {
      count++;
    },

    getCount() {
      return count;
    }
  };
}

const counter1 = counter();
const counter2 = counter();

counter1.increment();
counter1.increment();

console.log(counter1.getCount()); // выводит 2

counter2.increment();
counter2.increment();
counter2.increment();

console.log(counter2.getCount()); // выводит 3
```

> Здесь функция counter создает объект с двумя методами: increment(), который увеличивает значение переменной count, и getCount(), который возвращает значение переменной count. Переменная count объявляется внутри функции counter, поэтому она недоступна извне. Код создает два экземпляра счетчика, counter1 и counter2, которые имеют свои собственные значения count и методы increment() и getCount(). Каждый раз, когда мы вызываем метод increment() у counter1 или counter2, значение переменной count увеличивается на 1, и соответствующий счетчик возвращает своё значение через метод getCount(). Это позволяет нам создавать приватные переменные и функции, которые не будут доступны извне и не изменятся из-за работы других методов.

